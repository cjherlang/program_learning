容器，类模板，传入相应数据类型成为相应的类，-> 相应的对象（容器对象）

类模板 -> 类 -> 对象（属性和方法）
属性：size，empty, begin，end，rbegin，rend，
行为：增删改查， 各自特性

对容器的操作，一般是基于迭代器的（指针，地址的）初始化，访问等等

顺序容器：存储顺序结构的容器，有一定的顺序而言
关联容器：存储key-value结构的容器，无顺序可言
迭代器：指针，存取，移动

顺序容器：
不同的顺序容器有不同的特性
vector, deque 连续的存储的空间，都支持随机访问[] , c.at(i);要注意下标不要越界，都是连续的存储的空间，deque首尾都能进行操作，而vector只能在尾端进行操作
list，链式存储，能够在首尾进行操作，而且删除，其他的迭代器不会失效
vector：连续的存储空间，存取效率高，只能在尾端进行操作，而且删除效率低
deque：存取效率没有vector那么高，但首尾都能进行操作
list：存取效率不高，但删除效率高，且其他迭代器不会失效（原来的迭代器还是指向原来的元素），首尾都能进行操作
一般用vector进行存储(存取效率高)，如果需要特殊操作那么可以考虑deque（在两端能够进行直接操作，vector只能在尾端进行直接操作）和list
(对删除有着极高的效率，且删除迭代器不会失效，但对访问效率不高，需要遍历一遍)
操作：
增删改
查：顺序容器都没有find函数（string例外）,查找都得用泛型算法，find

关联容器
pair：结构体模板(key-value)，make_pair 来产生具体的对象，
map：key-value(pair)形式，key值唯一，
操作：
增删改查
添加[],insert

迭代器
迭代器，指针(地址)，（容器中的数据类型决定了它是什么指针）
迭代器连接了算法与容器
迭代器的操作：
存取
移动


泛型算法：与容器无关的，它是基于迭代器的，是通过使用迭代器来进行实现的（也依赖于容器内存储的元素，需要支持相应的比较操作 如 ==， <）
迭代器能进行的操作：移动，存取
对于部分泛型算法，要么给它提供一个比较函数，要么它就会使用默认的运算符来进行操作
泛型算法，它是看不到容器的，所以它也不能进行容器的操作，erase，insert

find查找
find_first_of查找两个容器中第一个相等的元素
sort（排序）
stable_sort（稳定排序）
unique（唯一化）：只对相邻的有效，所以用之前需要排下序，让相邻的在一起
remove（去除）：只是把要删除的移到尾端
remove_if
count_if（统计）

find泛型算法find(遍历)，比起容器自带的find算法效率要低（string，map），但它通用
排序算法默认是升序的，如果我们要让它是降序的，那么我们需要传入比较函数，或者重载小于符号