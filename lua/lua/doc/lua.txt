lua:数据声明 +数据处理

lua，只有对象没有类型（仅值有类型），所有的操作都是基于对象的


一、数据声明：类型（基本类型，特殊类型），动态类型语言,变量无类型，值有类型（类型间的转换由编译器完成）
所有值一样都是匿名的（即使它们没有名称），我们只是通过一个变量去持有它，使用它，甚至改变它
基本值类型：同其他语言，布尔，字符串，浮点

特殊类型：
（1）table:关联数组
数组部分（顺序结构） +　哈希表部分（关联结构）
放入数组还是哈希表：数组部分试图保存所有key值介于1和某个上限n之间的值，非整数key和超过数据范围n的整数key对应的值将存入哈希表部分。
对于数组部分，要求的数组的大小同时满足：1到n之间至少一半的空间被利用（避免像稀疏数组一样浪费空间）；并且n/2+1到n之间的空间至少有一个空间被利用（避免n/2个空间就能容纳所有数据时申请了n个空间浪费）。
遍历：
查找：
访问key：
table长度：#来取得数组部分的长度
和数组可以一样用{}来初始化

索引：索取引导，查找的标志，table数组部分的索引是从1开始的

一个table想象成一种动态分配的对象，程序仅仅持有一个对他们的引用（或指针），Lua不会暗中产生table的副本或创建新的table。table永远是匿名的（anonymous），一个持有table的变量与table自身没有固定的关联性
只是通过一个变量去持有它,使用它

元表(MetaTable)：保存最基础的东西，默认的东西，访问一个元素不存在（数据）__index，执行一个不支持的操作（方法），都会用到
元方法(MetaMethod)：元表中保存的方法，最基础的方法，
__index:访问元方法(变量,可以赋值任意东西，持有任意东西,也可以赋值个table给他)，当访问一个table中不存在的字段时，解释器会在元表中找一个__index的元方法，有这个方法就返回这个方法的结果，没有这个方法就返回nil
__newindex：赋值元方法，赋值时，有这个方法就赋值这个方法的结果，没有则就赋传入的值
(*继承，面向对象)
在lua代码中，只能设置table的元表，若要设置其他类型的值得元表，则必须通过C代码来完成

table的函数：
table.sort(table, orderFunction)


二、数据处理：
1、基本处理：
基本运算符；=支持一个等号，多个赋值
基本语句：if，while，repeat until（do while），for（基本for（可带步长，变化值）， 泛型for（key， value））


2、语言特性：
（1）字符串操作：
..：连接字符串
tonumber
tostring
#:放于字符串前，取得字符串的长度

(2)函数：
函数：可以返回多个值，直接return，在一个表达式中，如果不是最后一个参数，那么它只返回一个值
1、第一类值（同其他的值一样）：函数与所有其他所有值一样都是匿名的（即使它们没有名称），我们只是通过一个变量去持有它，使用它，甚至改变它
2、closure(闭包函数)：一个closure就是一个函数加上该函数所需访问的所有“非局部的变量”（高阶函数中的局部变量）。
如果重新调用高阶函数，那么高阶函数里面的局部变量都会重新申请，那么里面的局部函数也是一样的（该特性可用来创建对象）
从技术层面，可以认为所有的函数都是closure，它们都含有非局部变量区

使用冒号：来隐藏self参数（相当于this参数），让对象和名称无依赖关系。冒号只是一种简写，和传入self是等价的


（3）面向对象：
lua，只有对象没有类型（只有值有类型），所有的操作都是基于对象进行的
类：lua中没有类的概念，每个对象只能自定义行为和形态，可以通过设置原型对象来实现该对象的“类型”（该具有的特性）
设置元表对象，添加，重写，多重继承实在__index元方法中完成的,setmetatable(a, {__index = b})

为了创建多个的一类对象，那么我们需要把这个该对象设置为创造出来的对象的元表，让创建出来的对象具有该对象的方法
	o = o or {}
    setmetatable(o,self)
    self.__index = self
	
封装：table
继承：SpecialAccount = Account:new()  --此时SpecialAccount仍然为Account的一个对象实例
	--在执行下面的new方法时，table s的元表已经是SpecialAccount了，而不再是Account。self参数已经是SpecialAccount，而不再是Account了
	s = SpecialAccount:new{limit = 1000.00}
	
多态：暴露接口，隐藏实现

和c++的交互：

（4）模块
模块类似于一个封装库，可以把一些公用的代码放在一个文件里，以 API 接口的形式在其他地方调用，有利于代码的重用和降低代码耦合度。
Lua 的模块是由变量、函数等已知元素组成的 table，因此创建一个模块很简单，就是创建一个 table，然后把需要导出的常量、函数放入其中，最后返回这个 table 就行
require 用于搜索 Lua 文件的路径是存放在全局变量 package.path 中，当 Lua 启动后，会以环境变量 LUA_PATH 的值来初始这个环境变量。如果没有找到该环境变量，则使用一个编译时定义的默认路径来初始化。
执行 require 后会返回一个由模块常量或函数组成的 table，并且还会定义一个包含该 table 的全局变量。

使用require(“model_name”)来载入别的lua文件，文件的后缀是.lua。载入的时候就直接执行那个文件了
1）require函数，载入同样的lua文件时，只有第一次的时候会去执行，后面的相同的都不执行了。
2）如果你要让每一次文件都会执行的话，你可以使用dofile(“hello”)函数
3）如果你要玩载入后不执行，等你需要的时候执行时，你可以使用 loadfile()函数，
loadfile(“hello”)后，文件并不执行，我们把文件赋给一个变量hello，当hello()时，才真的执行


（5）热更新




metaTable的元方法：
至于__add这是MetaMethod，这是Lua内建约定的，其它的还有如下的MetaMethod：
__add(a, b)                     对应表达式 a + b
__sub(a, b)                     对应表达式 a - b
__mul(a, b)                     对应表达式 a * b
__div(a, b)                     对应表达式 a / b
__mod(a, b)                     对应表达式 a % b
__pow(a, b)                     对应表达式 a ^ b
__unm(a)                        对应表达式 -a
__concat(a, b)                  对应表达式 a .. b
__len(a)                        对应表达式 #a
__eq(a, b)                      对应表达式 a == b
__lt(a, b)                      对应表达式 a < b
__le(a, b)                      对应表达式 a <= b
__index(a, b)                   对应表达式 a.b
__newindex(a, b, c)             对应表达式 a.b = c
__call(a, ...)                  对应表达式 a(...)